# ﻿JENKINS ARBITRARY FILE READ WRITEUP
## Ian Melven
### https://twitter.com/imelven
#### 9/5/2018

I decided to try to write an exploit for a recent Jenkins vulnerability: [SECURITY-914 / CVE-2018-1999002](https://jenkins.io/security/advisory/2018-07-18/)

From the [bulletin](https://jenkins.io/security/advisory/2018-07-18/): 

```Arbitrary file read vulnerability 
SECURITY-914 / CVE-2018-1999002

An arbitrary file read vulnerability in the Stapler web framework used by Jenkins allowed unauthenticated users to send crafted HTTP requests returning the contents of any file on the Jenkins master file system that the Jenkins master process has access to.

Input validation in Stapler has been improved to prevent this.
```

This is the [patch to Stapler](https://github.com/stapler/stapler/commit/8e9679b08c36a2f0cf2a81855d5e04e2ed2ac2b3#diff-2ad5758ac928c69f512f0f0792d50fcc) that addresses the vulnerability. 

I decided to use an LTS version of Jenkins to research the vulnerability. The bulletin says Jenkins LTS should be updated to version 2.121.2 and hence I downloaded the [Jenkins Docker container](https://hub.docker.com/r/jenkins/jenkins/) containing version 2.121.1 of Jenkins: 

```
docker pull jenkins/jenkins:2.121.1
```

I wanted to attach a debugger (IntelliJ IDEA) to the Jenkins Docker container. The jenkins.sh in the 2.121.1 Jenkins Docker container doesn't have code to start Jenkins with the necessary debugging flags it so I start the container with :

```
docker run -it -e DEBUG=true -p 5005:5005 -p 8080:8080 -p 50000:50000 jenkins/jenkins:2.121.1 bash
```

then copy in the [latest version of jenkins.sh](https://github.com/jenkinsci/docker/blob/master/jenkins.sh) that has added the debug handling:

```
 if [[ "$DEBUG" ]] ; then
    java_opts_array+=( \
      '-Xdebug' \
      '-Xrunjdwp:server=y,transport=dt_socket,address=5005,suspend=y' \
    )
  fi
```

with: 
```
docker cp jenkins.sh <container name>:/usr/local/bin/jenkins.sh
```

I pulled [Jenkins source](https://github.com/jenkinsci/jenkins) and then checked out the version running in the container: 

```
git checkout tags/jenkins-2.121.1
```

Jenkins 2.121.1 is using Stapler 1.254

I got Stapler source JARs [here](http://repo.jenkins-ci.org/public/org/kohsuke/stapler/stapler/1.254/)

The vulnerable function in Stapler is [LocaleDrivenResourceSelector::Open](https://github.com/stapler/stapler/blob/stapler-parent-1.254/core/src/main/java/org/kohsuke/stapler/Stapler.java#L343)

I'm targeting this line :

```
con = openURL(map(base + '_' + language + ext));
```

The issue is that language is a value controlled by the attacker, as it’s read from the Accept-Language header on the HTTP request to Stapler. The basic ideas is to set an Accept-Language header with something like ../.. as the value, which would then let us perform a directory traversal and read any arbitrary file. 

LocaleDrivenResourceSelector is an abstract class and is used in two places:

```
private final LocaleDrivenResourceSelector resourcePathLocaleSelector = new LocaleDrivenResourceSelector() {

private final LocaleDrivenResourceSelector urlLocaleSelector = new LocaleDrivenResourceSelector() {
```

These two objects have their Open method called from one location each : 

```
    OpenConnection openResourcePathByLocale(HttpServletRequest req,String resourcePath) throws IOException {
        URL url = getResource(resourcePath);
        if(url==null)   return null;

        // hopefully HotSpot would be able to inline all the virtual calls in here
        return resourcePathLocaleSelector.open(resourcePath,req.getLocale(),url);
    }

    OpenConnection selectResourceByLocale(URL url, Locale locale) throws IOException {
        // hopefully HotSpot would be able to inline all the virtual calls in here
        return urlLocaleSelector.open(url.toString(),locale,url);
    }
```

I looked at openResourcePathByLocale first. This is called by [one location](https://github.com/stapler/stapler/blob/stapler-parent-1.254/core/src/main/java/org/kohsuke/stapler/Stapler.java#L223). 

This is in the main Stapler's class service() method which handles the bulk of requests to Jenkins. At first this seemed awesome, since pretty much every web request including unauthenticated requests goes through here ! The bulk of Jenkins routes/URLs require authentication unless the class handling the request implements UnprotectedRootAction. This will be relevant later. 

However, note the [getResource() call](https://github.com/stapler/stapler/blob/stapler-parent-1.254/core/src/main/java/org/kohsuke/stapler/Stapler.java#L399)...

This is before our evil unsanitized Accept-Language header has been processed. This means the original request must be for a resource that already exists on the server (ideally one that's part of an UnprotectedRootAction so we don't need to authenticate) which is a constraint. It seems like we could work past this though... except there's a few more wrinkles for this path...

LocaleDrivenResourceSelector::Open does a few more checks we need to get through :

```
 int idx = s.lastIndexOf('.');
 
  if(idx<0)   // no file extension, so no locale switch available
   return openURL(fallback);
 
 String base = s.substring(0,idx);
 String ext = s.substring(idx);
 
  if(ext.indexOf('/')>=0) // the '.' we found was not an extension separator
   return openURL(fallback);
```

so there must be a . somewhere in the URL path we're requesting and there CANNOT be a / after it. 

This isn't too hard to work around using a ? (URL query separator) at the end of the Accept-Language header. 

The trickier part here is the calls in the target line:
```
con = openURL(map(base + '_' + language + ext));
```

At this point in the Stapler code, we're building our directory traversal string.

If we use a URL like https://<jenkins server>/images/headshot.png [Remember, this URL must point to a file that exists on the server due to the prior getResource() check before entering Open() ]
and an Accept-Language header of "../../../flag.txt?", when we do the string concatenation, we end up passing /images/headshot_../../../flag.txt?.png to map()

resourcePathLocaleSelector implements map() as

```
  private final LocaleDrivenResourceSelector resourcePathLocaleSelector = new LocaleDrivenResourceSelector() {
        @Override
        URL map(String path) throws IOException {
            return getResource(path);
        }
```

so this path gets passed to getResource

```
    /*package*/ URL getResource(String name) throws MalformedURLException {
        if (resourcePaths!=null)
            return resourcePaths.get(name);
        else
            return context.getResource(name);
    }
```

resourcePaths is defined as 

```
    /**
     * All the resources that exist in {@link ServletContext#getResource(String)},
     * as a cache.
     *
     * If this field is null, no cache.
     */
    private volatile Map<String,URL> resourcePaths;
```

so if the path doesn't exist in this Map, we can go no further..

Where does resourcePaths come from? 

The [call to buildResourcePaths() in Stapler::Init](https://github.com/stapler/stapler/blob/stapler-parent-1.254/core/src/main/java/org/kohsuke/stapler/Stapler.java#L142)

This function caches all the files existing on the server on startup and sticks them in a Map which maps their path to a URL pointing to them so the server can easily load their content.

This cache can be disabled :

```
    public void buildResourcePaths() {
        try {
            if (Boolean.getBoolean(Stapler.class.getName()+".noResourcePathCache")) {
                resourcePaths = null;
                return;
            }
```

but this seems to be on by default in Jenkins, or at least in the official Docker container Jenkins I was testing against :(

This is where I gave up on this exploitation path since the file path needing to be in the cache of already accessible files seems to mean there's no way to do an arbitrary file read :(

BUT there is another possible path to victory via selectResourceByLocale! 

This is called in one location in ResponseImpl.java :

```
    public void serveLocalizedFile(StaplerRequest request, URL res, long expiration) throws ServletException, IOException {
        if(!stapler.serveStaticResource(request, this, stapler.selectResourceByLocale(res,request.getLocale()), expiration))
            sendError(SC_NOT_FOUND);
    }
```

Hence, now we're looking for calls to serveLocalizedFile.

There's one in Stapler::responseImpl: 

```
    public void serveLocalizedFile(StaplerRequest request, URL res) throws ServletException, IOException {
        serveLocalizedFile(request,res,-1);
    }
```

This method is basically just a wrapper specifying no expiration, which is passed to the real implementation of serveLocalizedFile.

The two other calls to serveLocalizedFile are in the Jenkins code itself and not in Stapler.

One is in the [AssetManager](https://github.com/jenkinsci/jenkins/blob/jenkins-2.121.2/core/src/main/java/jenkins/model/AssetManager.java#L66)

This is in AssetManager::doDynamic, which has a comment stating:
```
  /**
    * Exposes assets in the core classloader over HTTP.
    */
```

The AssetManager itself has this comment:

```
 * Serves files located in the {@code /assets} classpath directory via the Jenkins core ClassLoader.
 * e.g. the URL {@code /assets/jquery-detached/jsmodules/jquery2.js} will load {@code jquery-detached/jsmodules/jquery2.js}
 * resource from the classpath below {@code /assets}.
```

Also note : 
```
public class AssetManager implements UnprotectedRootAction {
```

and :

```
    @Override
    public String getUrlName() {
        return "assets";
    }
```

This means the AssetManager is an UnprotectedRootAction and correspondingly everything under /assets is available without authentication. Awesome!


However, before calling serveLocalizedFile, doDynamic() does this:
```
        String path = req.getRestOfPath();
        URL resource = findResource(path);


        if (resource == null) {
            rsp.setStatus(HttpServletResponse.SC_NOT_FOUND);
            return;
        }
```

findResource is also [implemented in the AssetManager](https://github.com/jenkinsci/jenkins/blob/jenkins-2.121.2/core/src/main/java/jenkins/model/AssetManager.java#L77):

```
     if (path.contains("..")) // crude avoidance of directory traversal attack
                throw new IllegalArgumentException(path);


            String name;
            if (path.charAt(0) == '/') {
                name = "assets" + path;
            } else {
                name = "assets/" + path;
            }


            ClassLoader cl = Jenkins.class.getClassLoader();
            URL url = (URL) $findResource.invoke(cl, name);
            if (url==null) {
                // pick the last one, which is the one closest to the leaf of the classloader tree.
                Enumeration<URL> e = cl.getResources(name);
                while (e.hasMoreElements()) {
                    url = e.nextElement();
                }
            }
            return url;
```

The path always has "assets" appended to it. Then we attempt to find the resource with this path via one of the class loaders.

$findResource is set up like so:

```
    private static final Method $findResource = init();

    private static Method init() {
        try {
            Method m = ClassLoader.class.getDeclaredMethod("findResource", String.class);
            m.setAccessible(true);
            return m;
        } catch (NoSuchMethodException e) {
            throw (Error)new NoSuchMethodError().initCause(e);
        }
    }
```

The comment above findResource gives us some explanation:

```
     * Locates the asset from the classloader.
     *
     * To allow plugins to bring its own assets without worrying about colliding with the assets in core,
     * look for child classloader first. But to support plugins that get split, if the child classloader
     * doesn't find it, fall back to the parent classloader.
     */
```

Jenkins.class.getClassLoader() in my debugging gave me an instance of WebAppClassLoader.

My assumption is that in another web server running jenkins.war other than Jetty, this may be a different class, which is why this is dynamic. 

As far as I can tell from my debugging, the end result of this code is that the /assets/<whatever path we asked for> is searched for in the class loader hierarchy. Most of these class loaders load resources from the JAR files in the assets directory. 

For example, a request for assets/jquery-detached/jsmodules/jquery2.js ends up loading this URL:  

```
jar:file:/var/jenkins_home/war/WEB-INF/lib/jquery-detached-1.2.1-core-assets.jar!/assets/jquery-detached/jsmodules/jquery2.js"
```

This doesn't seem like it could lead to an arbitrary file read, since the file you want to read has to be one that a class loader knows about and these will only be the files in the JAR files in the assets directory on the server. They also have to begin with "assets" due to this always being appended in the AssetManager code. I suppose it could be theoretically possible that a plugin could use a class loaded to load something not in a JAR file and then this might be more useful. I played around with this a bit as one class loader is not pointing to a JAR and there's a possibly targetable file in the /assets directory but couldn't get anywhere with that either.. I could only modify the path after /assets that is passed to findResource and look for things in different JAR files. These are all intended to be assets accessible publicly with no authentication so this seems like a dead end... 

The [other call to serveLocalizedFile()](https://github.com/jenkinsci/jenkins/blob/jenkins-2.121.2/core/src/main/java/hudson/Plugin.java#L250) is in hudson.Plugin::doDynamic which has a comment describing what the method does: 
```This method serves static resources in the plugin under <tt>hudson/plugin/SHORTNAME</tt>.```

[Stapler routing](http://stapler.kohsuke.org/reference.html) took me a while to understand.

The important part is that you can hit doDynamic by requesting something like /plugin/git/blah as the comment hints at.

I looked at the git plugin since it's commonly used. Unfortunately accessing /plugin/git/blah requires Overall/Read permissions and cannot be accessed without authentication :(

Anyways, arbitrary file read requiring authentication is still pretty cool, you could potentially snag the Jenkins secrets or other useful things... but not as cool as no authentication arbitrary file read :(

So let's keep going:

```
if (path.isEmpty() || path.contains("..") || path.startsWith(".") || path.contains("%")
                || pathUC.contains("META-INF") || pathUC.contains("WEB-INF")
                // ClassicPluginStrategy#explode produce that file to know if a new explosion is required or not
                || pathUC.equals("/.TIMESTAMP2")
        )
```

Notice that doDynamic attempts to prevent a bunch of evil things from happening and there must be *something* in the path after /plugin/<plugin name> which is why I'm using /plugin/git/blah as an example. Also notice that our malicious Accept-Language header hasn't been added to path yet at this point.

Some other stuff happens that isn't relevant to our exploitation attempt and then
'''
rsp.serveLocalizedFile(req, new URL(wrapper.baseResourceURL, '.' + path), expires)
'''
 is called. 

Let's say I request a URL of https://<jenkins server>/plugin/git/foo.txt
and send an Accept-Language header of "../../../../../flag.txt?"

This gets passed to serveLocalizedFile with our URL of plugin/git/foo.txt and then eventually
passed to LocaleDrivenResourceSelector::Open

We pass the checks in this method because there's a . and no / after the . in our URL

We then add the evil Accept-Language header *AND* an underscore also gets added :(

```
 con = openURL(map(base+'_'+ locale.getLanguage()+ext));
```

This means we're going to pass to map() something like file:/var/jenkins_home/plugin/git/foo_/../../../../../flag.txt?.txt here 

Will map trip us up again via doing a cache check here? No! 

```
    private final LocaleDrivenResourceSelector urlLocaleSelector = new LocaleDrivenResourceSelector() {
        @Override
        URL map(String url) throws IOException {
            return new URL(url);
        }
    };
```

urlLocaleSelector::map just returns a new URL constructed from the string version of the URL we passed in. Cool!

But... this still doesn't work because of that darn UNDERSCORE.

On Windows, you can .. up through a directory that doesn't exist.. 

For example: dir C:\windows\isfunny\.. will give you a directory listing of C:\windows

but Linux and OSX don't work this way. 

So we end up getting a 404 here. If there was a directory somewhere under one of the plugin directories with a _ in it, this path could work - but on the Jenkins Docker image with the 'standard' plugins installed during initial Jenkins setup, there isn't one.

Also note that the file URL is converted to a File Java object and as part of this is run through URLDecoder.decode() : 

```
File toFile(URL url) {
  String urlstr = url.toExternalForm();
  if (!urlstr.startsWith("file:")) {
    return null;
  } else {
    try {
      return new File(URLDecoder.decode(urlstr.substring(5), "UTF-8"));
    } catch (UnsupportedEncodingException var4) {
      throw new AssertionError(var4);
    }
  }
}
```

but unfortunately x-www-form-urlencoded format leaves the underscore untouched and passes it directly through :(

In conclusion, in the default and many common configurations, especially not on Windows, this vulnerability doesn’t seem to be exploitable. On Windows, it can definitely be exploitable as long as there’s a plugin whose URL can be used to carry out the directory traversal. It’s also possible it’s exploitable when Jenkins has a plugin installed that has a directory with a _ in the name that can be used to work around the _ always being included in the file path. I believe that Jenkins made the right decision patching this as a high severity vulnerability, given that it’s very difficult to accurately determine if you’re vulnerable, since it depends on plugin behaviour and which plugins are installed, what platform you are running, if caching is enabled/disabled, and potentially even what web application server you are running Jenkins under - and if you are vulnerable, the impact is quite severe and can lead to compromise of all Jenkins secrets. 

A special thanks to Daniel Beck of CloudBees and orange_tsai, the original finder of the bug, for reviewing my research. orange_tsai also pointed me to another [writeup of this vulnerability in Chinese](https://www.anquanke.com/post/id/152955) which covers a few other details, like using the vulnerability to read Jenkins secrets, which can lead to remote code execution via the Jenkins script console. 

Greetz to all who contributed in some way to this research: dmuz, ottomatic jack, Josh Farwell, mcmayhem, othiym23, orange_tsai (great work finding this bug!)
